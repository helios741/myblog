# 如何察觉代码坏味道：依赖

基本上所有依赖相关的坏味道都是和封装有关系，可能是封装过度更可能是封装不完善，本文会详细讲解在编程工作中一定会遇到的五个问题，让你体会一下**高内聚、低耦合**六个字。希望你看完之后能审视一下自己的代码。



⚠️注：本文来自读《重构2》之后的感受以及对最近编码的反思，如有雷同，那只能说你爱学习也读过这本书，如果你感觉特别雷同，那你可能是我同事。

------



![](/Users/helios/Desktop/helios/myblog/src/2021/03/summary.png)

本文并不会按照书上摘抄着讲，而是结合自己编程经验讲解上图中的六个坏味道并且用大白话给你总结一下，看你遇到过下面的坏味道没：

- 你修改代码为什么让我也修改
- 我加个东西怎么会影响这么多
- 不敢动的祖传代码
- 别人和你说这段代码以后有用，但是从来没用过
- 要获得一个属性有很多点号(.)，比如user.Property.Like.Names
- 明确分层之间因为参数而继续耦合，比如controller接受的参数和service接受的参数类型是一样的
- 替换一个依赖的时候伤筋动骨

## **修改的难题**

你在编程工作中一定经历过下面这两种情况：

1、 怎么谁修改代码都会影响到我呀。

2、 我就改个字段怎么需要修改这么多东西，不由的**发出牵一发而动全身**的感叹。

这个就分别对应分散式变化和霰弹式修改，如果你去看原文大概率会被弄蒙。

分散式变化的解释如下：

> 如果某个模块经常因为不同的原因在不同的方向上发生变化，发散式变化就出现了。当你看着一个类说：“呃，如果新加入一个数据库，我必须修改这3个函数；如果新出现一种金融工具，我必须修改这4个函数。”这就是发散式变化的征兆。数据库交互和金融逻辑处理是两个不同的上下文，将它们分别搬移到各自独立的模块中，能让程序变得更好：每当要对某个上下文做修改时，我们只需要理解这个上下文，而不必操心另一个。“每次只关心一个上下文”这一点一直很重要。当然，往往只有在加入新数据库或新金融工具后，你才能发现这个坏味道。程序刚开发出来还在随着软件系统的能力不断演进时，上下文边界通常不是那么清晰。
>
> 《重构2》3.7

霰弹式修改解释如下：

> 霰弹式修改类似于发散式变化，但又恰恰相反。如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是霰弹式修改。如果需要修改的代码散布四处，你不但很难找到它们，也很容易错过某个重要的修改
>
> 《重构》3.8

你可能看到这里虽然有点理解但是不太能对应的起来，我就以我毕业后第一家公司的真实遭遇来说说这两个东西：公司高层决定改变组织架构发现所有的员工都要变化（霰弹式修改：一处动到处动），我的leader A离职了，B成为那一块业务的leader，C0变成了我的leader，C1变为了小组负责人，有下面几个场景：

1、 当一个需求来了，B是个老油条，说以前做这个的人去C组了，先安排给他吧

2、 C1说，你刚来，这块你来看看吧

3、 上头又来了个活交给C0组，C0看了一眼，主观觉得和我有关，问都没问说就交给Helios吧

4、 有一天你在工位上工作，然后领导过去说“你去前台把奶茶拿来”

这就不得不发出**怎么啥事都找我呀**，这就是**分散式变化**。



看到这里你可能理解了这两个概念，但是和这两个词对应不起来，那么就别对应了记住就行。这两种存在的本质都是在于违背了单一职责原则。我们来以一个电商中关于用户的实体来举例子，最开始

```go
type User struct {
  Name string
  Password string
  Addr []string

  Like string

  Tag []string
  ConsumeTotalTimes int64

  ConsumeTotalMoney int64

  // ...

}
```

