# 再谈DIP: 如何编写可测试代码

在前一篇文章[什么是SOLID设计原则](https://github.com/helios741/myblog/tree/new/learn_go/src/2021/04/solid)详细解释了什么SOLID的原则。今天我们通过一个搞项目的案例来真实的体验一下，做好了DIP之后让单元测试写起来爽翻天。



## 单元测试的重要性

单元测试在现今项目中的重要性不言而喻，尤其是Bob大叔大力宣扬单元测试，甚至在《代码整洁之道》中还说出覆盖率要尽可能的百分之百（可以看我写的笔记[《代码整洁之道：程序员的职业素养》](https://mp.weixin.qq.com/s/iIc-H50_uSdd73zQEMdWMQ)），因为这个两个编程老牛还公开掐过架（见[Coplien and Martin Debate TDD, CDD and Professionalism](http://www.infoq.com/interviews/coplien-martin-tdd)）。以我的资历肯定不可能评价Bob大叔和Jim Coplien，但是还是要说说的我的看法。个人觉得Bob大叔的想法有点偏激，毕竟在业务中老板是过来请你写代码的不是请你来写单测的，要是按照Bob大叔提倡的TDD，那基本写不了快糙猛的代码了。我认为写单元测试的地方有下面几个：

1、 出现过bug的地方，写单测是为了以后不会出现同样的bug

2、 方便的地方，如果你正在接运营商的短信服务，在测试可用性的时候没必要走全流程，走可用流程即可

3、 公用方法，这种必须保证正确并且增加到CI中，因为过于重要必须保证可用

4、 容易让人理解，在看go语言的开源项目的时候单测能让人很好理解，一是因为能马上运行局部代码看到效果，二是了解这个函数输入



对于业务测试尽量遵循好第一个原则即可。



## 业务代码写单测的困境

一句话就是*依赖*太多。

![image-20210420193108311](/Users/helios/Library/Application Support/typora-user-images/image-20210420193108311.png)

以典型的三层架构为例（表示层/转换层 --> 逻辑层 --> 访问层）。审视一下你的代码（专指后端业务代码），能不能做到不初始化DB就能测试；能不能做到不引入全局的包（比如静态配置、私有日志库）就能测试。如果你的回答是否定的并且还还认可我这幅图，那么就证明你的代码正在深陷泥潭。

如果上图的箭头表示控制的方向，那么大概率你的代码是不可测试的，不可测试的代码基本等于不能修改或者重构，不能修改或者重构的代码基本等于死代码，死代码咱就别说了，成天就剩下抱怨了，抱怨产品经理需求多，抱怨前任写的代码搓，抱怨同事不会体谅人。



虽然可以不采用TDD的模式去开发，但是如果代码不可测试就证明耦合太严重。



## 业务单测的前提

那么如果破局呢，其实只要将上图中的一个两个箭头换个方向即可，即：

![image-20210420193920851](/Users/helios/Library/Application Support/typora-user-images/image-20210420193920851.png)

只要把业务逻辑层和数据访问层的**依赖倒置**就可以了。这时候业务逻辑层就回归了中心的位置（他本身就应该是中心位置，老板只关系你功能实现没实现，管你存在哪干啥）。那么怎么做到数据访问层依赖业务逻辑层呢，这其实用的java中已经很成熟的技术了，叫依赖注入。



## 获取学生信息案例

项目地址





在[什么是SOLID设计原则](https://github.com/helios741/myblog/tree/new/learn_go/src/2021/04/solid)中介绍了DIP，提炼为下面两句话

- 高层不应该依赖底层，二者应该依赖抽象
- 抽象不应该细节，细节应该依赖抽象

这次我们通过例子来解读下这两句话

